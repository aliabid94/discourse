<html>
<head>
  <title>Discourse</title>
  <link href="{{ url_for('static', filename='style/style.css') }}" rel="stylesheet">
  <meta name="viewport" content="width=device-width">
</head>
<body>
  <div class="container">
    <div class="top">
      <a href="/"><h1>Discourse</h1></a>
      {% if current_user.is_authenticated %}
      <div class="welcome">Hi, {{ current_user.id }} &bull;
        <a class="link" href="/submit">Submit</a> &bull; 
        <a class="link" href="/logout?redirect=/{{article['id']}}">Logout</a>
      </div> 
      {% else %}
      <a class="link" href="/login?redirect=/{{article['id']}}">Sign In</a>
      {% endif %}
    </div>
    <div class="line1">
      <a class="upvote link">â–²</a> 
      <a class="article_link" href="{{ article['url'] }}">{{article["headline"]}}</a>
      {% if host %}<small>({{ host }})</small>{% endif %}
    </div>
    <div class="summary">{{article["summary"]}}</div>
    <hr>
    <p class="attention" id="discussion_rules">
      <strong>Discussion Rules</strong>: Use the space below for thoughtful conversation. Flag snarky comments or low-effort humor as <em>Low Quality</em>. Report comments that are insulting or spam. For comments you disagree with, use the <em>Disagree</em> button and engage the commentor with open curiousity.
      Comments are arranged to present many different viewpoints, not ordered by popularity.
    </p>
    <div id="discussion">
      <div class="top_reply">
        <a class="link" onclick="open_reply(this, /*top_level=*/true);">create new comment</a>
      </div>
    </div>
  </div>
  <script>
    let comments = {{comments|tojson}};
    let article_id = {{article["id"]}};
    let signed_in = {{ current_user.is_authenticated|tojson }};
    $ = document.querySelector.bind(document);
    $$ = document.querySelectorAll.bind(document);

    let id_to_comments = {};
    comments.map(comment => {id_to_comments[comment.id] = comment});
    for (let comment of comments) {
      if (comment.parent_id) {
        let parent_comment = id_to_comments[comment.parent_id];
        if (!parent_comment.children) {
          parent_comment.children = [];
        }
        parent_comment.children.push(comment)
      }
      comment.children_count = 0;
    }
    for (let i = comments.length - 1; i >= 0; i--) {
      let comment = comments[i];
      if (comment.parent_id) {
        let parent_comment = id_to_comments[comment.parent_id];
        parent_comment.children_count += 1 + comment.children_count;
      }
    }
    let getCommentCode = (comment, is_child) => {
      if (comment.deleted && comment.children_count == 0) {
        return "";
      } 
      let html = `<div class="comment ${is_child ? "child" : ""}" comment_id=${comment.id}>
        <a class="collapse" onclick="collapse(this);"><span class="close">[-]</span><span class="open">[+]</span></a>
        <a href="#${comment.id}" class="comment_author">${comment.author} ${comment.age}</a>
        ${comment.children_count > 0 ? `<span class="children_count"><span class="count">(+${comment.children_count}</span> children)</span>` : ""}
        <div class="comment_content">${comment.deleted ? "[deleted]" : comment.content}</div>
        <div class="comment_controls">
          <a class="link agreement" onclick="meta_comment(this, 'agree');">Agree ${comment.agrees > 0 ? "(" + comment.agrees + ")" : ""}</a> &bull;
          <a class="link agreement" onclick="meta_comment(this, 'disagree');">Disagree ${comment.disagrees > 0 ? "(" + comment.disagrees + ")" : ""}</a> &bull;
          <a class="link" onclick="meta_comment(this, 'low_quality');">Low Quality</a> &bull;
          <a class="link" onclick="meta_comment(this, 'report');">Report</a> &bull;
          <a class="link" onclick="open_reply(this, /*top_level=*/false);">Reply</a>
          ${comment["author"] == "{{ current_user.id }}" || {{ (current_user.type in ("pseudo", "mod"))|tojson }} ? `
            &bull; <a class="link" onclick="delete_comment(this);">Delete</a>` : ""
          }
        </div>`;
      if (comment.children) {
        for (child_comment of comment.children) {
          html += getCommentCode(child_comment, /*is_child=*/true);
        }
      }
      html += "</div>"
      return html;
    }
    let discussion_html = "";
    for (let comment of comments) {
      if (!comment.parent_id) {
        discussion_html += getCommentCode(comment, /*is_child=*/false);
      }
    }
    $("#discussion").innerHTML += discussion_html;
    let collapse = item => {
      let comment_element = item.parentElement;
      if (comment_element.classList.contains("collapsed")) {
        comment_element.classList.remove("collapsed");
      } else {
        comment_element.classList.add("collapsed");
      }
    };

    function post(url, data, method) {
      return fetch(url, {
        method: method || "POST", 
        body: JSON.stringify(data)
      })      
    }
    function meta_comment(item, action) {
      if (!signed_in) {
        location.href = "/login?redirect=/" + article_id; 
      }
      let comment_id = item.parentElement.parentElement.getAttribute("comment_id");
      let data = {"comment_id": parseInt(comment_id)};
      if (action == "agree") {
        data["agreement"] = 1;
      } else if (action == "disagree") {
        data["agreement"] = -1;
      } else if (action == "low_quality") {
        data["low_quality"] = true;
      } else if (action == "report") {
        data["violation"] = true;
      }
      post("/meta_comment", data).then((response) => {
        if (response.ok) {
          if (action == "agree" || action == "disagree") {
            item.parentElement.querySelectorAll(".agreement").forEach(agree_choice => {
              agree_choice.style.fontWeight = "normal";
            });      
          }
          item.style.fontWeight = "bold";
        }
      })

    }
    let open_replies = [];
    function open_reply(item, top_level) {
      if (!signed_in) {
        location.href = "/login?redirect=/" + article_id; 
      }
      let parent_id = top_level ? -1 : item.parentElement.parentElement.getAttribute("comment_id");
      if (open_replies.includes(parent_id)) {
        return;
      }
      open_replies.push(parent_id);
      item.parentElement.innerHTML += `<textarea autofocus></textarea><a class="link" onclick="submit_reply(this, ${top_level});">Submit</a>`
      item.style.display = "none";
    }
    function submit_reply(item, top_level) {
      let content = item.parentElement.querySelector("textarea").value;
      let parent_id = top_level ? null : item.parentElement.parentElement.getAttribute("comment_id");
      post("/comment", {
        "content": content, 
        "parent_id": parent_id,
        "article_id": article_id
      })
      .then(response => response.json())
      .then((response) => {
        window.location.hash = response["comment_id"];
        location.reload();
      })
    }
    function delete_comment(item) {
      let comment_id = item.parentElement.parentElement.getAttribute("comment_id");
      post("/comment", {
        "id": comment_id, 
      }, /*method=*/"DELETE").then(() => {
        location.reload();
      })
    }
    if (signed_in) {
      let upvote = document.querySelector(".upvote");
      fetch("/upvote?" + new URLSearchParams({"article_ids": article_id}))
      .then(response => response.json())
      .then(upvoted_article_ids => {
        if (upvoted_article_ids.length) {
          upvote.classList.add("upvoted");
        }
        upvote.addEventListener("click", evt => {
          post("/upvote", {"article_id" : article_id}).then(response => {
            if (response.ok) {
              upvote.classList.add("upvoted");
            }
          })
        });        
      })
    } else {
      document.querySelector(".upvote").setAttribute("href", "/login?redirect=/"+article_id);
    }
    let hash_handler = () => {
      let hash = window.location.hash;
      if (hash == "") {
        return;
      }
      hash = hash.substring(1)
      if (!isNaN(parseInt(hash))) {
        document.querySelector(`.comment[comment_id='${hash}']`).scrollIntoView();
      }
    }
    window.onhashchange = hash_handler;
    window.setTimeout(hash_handler, 1000);
  </script>
</body>
</html>
